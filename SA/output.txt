Token: keyword        Lexeme: function
Token: identifier        Lexeme: convert1x
Token: seperator        Lexeme: (
Token: identifier        Lexeme: fahr
Token: keyword        Lexeme: int
Token: seperator        Lexeme: )
Token: seperator        Lexeme: {
Token: keyword        Lexeme: return
Token: integer        Lexeme: 5
Token: operator        Lexeme: *
Token: seperator        Lexeme: (
Token: identifier        Lexeme: fahr
Token: operator        Lexeme: -
Token: integer        Lexeme: 32
Token: seperator        Lexeme: )
Token: operator        Lexeme: /
Token: integer        Lexeme: 9
Token: seperator        Lexeme: ;
Token: seperator        Lexeme: }
Token: seperator        Lexeme: %%
Token: keyword        Lexeme: int
Token: identifier        Lexeme: low
Token: seperator        Lexeme: ,
Token: identifier        Lexeme: high
Token: seperator        Lexeme: ,
Token: identifier        Lexeme: step
Token: seperator        Lexeme: ;
Token: keyword        Lexeme: get
Token: seperator        Lexeme: (
Token: identifier        Lexeme: low
Token: seperator        Lexeme: ,
Token: identifier        Lexeme: high
Token: seperator        Lexeme: ,
Token: identifier        Lexeme: step
Token: seperator        Lexeme: )
Token: seperator        Lexeme: ;
Token: keyword        Lexeme: while
Token: seperator        Lexeme: (
Token: identifier        Lexeme: low
Token: operator        Lexeme: <=
Token: identifier        Lexeme: high
Token: seperator        Lexeme: )
Token: seperator        Lexeme: {
Token: keyword        Lexeme: put
Token: seperator        Lexeme: (
Token: identifier        Lexeme: low
Token: seperator        Lexeme: )
Token: seperator        Lexeme: ;
Token: keyword        Lexeme: put
Token: seperator        Lexeme: (
Token: identifier        Lexeme: convert1x
Token: seperator        Lexeme: (
Token: identifier        Lexeme: low
Token: seperator        Lexeme: )
Token: seperator        Lexeme: )
Token: seperator        Lexeme: ;
Token: identifier        Lexeme: low
Token: operator        Lexeme: =
Token: identifier        Lexeme: low
Token: operator        Lexeme: +
Token: identifier        Lexeme: step
Token: seperator        Lexeme: ;
Token: seperator        Lexeme: }
Token: seperator        Lexeme: %%
LEXER COMPLETE!
<IDs> ::= <Identifier>
<Qualifier> ::= int
<Parameter> ::=  <IDs >  <Qualifier>
<Parameter List>  ::=  <Parameter>
<Opt Parameter List> ::=  <Parameter List>
<Opt Declaration List> ::= <Empty>
<Primary> ::= <Integer>
<Factor> ::= <Primary>
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Primary> ::= <Integer>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Expression> ::= <Expression> - <Term>
<Primary> ::= ( <Expression> )
<Factor> ::= <Primary>
<Primary> ::= <Integer>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Term> ::= <Term>  /  <Factor>
<Term> ::= <Term>  *  <Factor>
<Expression> ::= <Term>
<Return> ::=  return <Expression> ;
<Statement> ::= <Return>
<Statement List> ::= <Statement>
<Body>  ::=  {  < Statement List>  }
<Function> ::= function  <Identifier>   ( <Opt Parameter List> )  <Opt Declaration List>  <Body>
<Function Definitions>  ::= <Function>
<Opt Function Definitions> ::= <Function Definitions>
<Qualifier> ::= int
<IDs> ::= <Identifier>
<IDs> ::= <Identifier> , <IDs>
<IDs> ::= <Identifier> , <IDs>
<Declaration> ::=   <Qualifier > <IDs>
<Declaration List>  := <Declaration> ;
<Opt Declaration List> ::= <Declaration List>
<IDs> ::= <Identifier>
<IDs> ::= <Identifier> , <IDs>
<IDs> ::= <Identifier> , <IDs>
<Scan> ::= get ( <IDs> ) ;
<Statement> ::= <Scan>
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Relop> ::= == | /= | > | < |  => | <=
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Condition> ::= <Expression> <Relop> <Expression>
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Print> ::= put ( <Expression> ) ;
<Statement> ::= <Print>
<IDs> ::= <Identifier>
<Primary> ::= <Identifier> ( <IDs> )
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Print> ::= put ( <Expression> ) ;
<Statement> ::= <Print>
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Primary> ::= <Identifier>
<Factor> ::= <Primary>
<Term> ::= <Factor>
<Expression> ::= <Term>
<Expression> ::= <Expression> + <Term>
<Assign> ::= <Identifier> = <Expression> ;
<Statement> ::= <Assign>
<Statement List> ::= <Statement>
<Statement List> ::= <Statement> <Statement List>
<Statement List> ::= <Statement> <Statement List>
<Compound> ::= {  <Statement List>  }
<Statement> ::= <Compound>
<While> ::=  while ( <Condition> ) <Statement>
<Statement> ::= <While>
<Statement List> ::= <Statement>
<Statement List> ::= <Statement> <Statement List>
<Rat19F>  ::=   <Opt Function Definitions>   %%  <Opt Declaration List>  <Statement List>  %%
Parsing complete.
