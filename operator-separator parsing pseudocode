divides separators and operators into a few categories for parsing-
- requiring disambiguation (one- or two-char seps/ops with matching first characters)
- easily-matched one-char seps/ops
- two-char seps/ops requiring an additional check of the next char in line
-- if check for second char matches remember to rat.get() to properly advance the file parse; if not matched it should not be advanced (same as doing a second get() instead of peek() then using unget() but a bit cleaner?)


char disambig[] = {"*","<",">","/","="};

char onec_seps[] = {"(",")",";","{","}", ","};
char twoc_seps_ch1[] = {"%","["};

char onec_ops[] = {"+","-"};
char twoc_ops_ch1[] = {"!"};


void FSMdisambig(){
//*: check for ]; might be uneccesary since *] should only be at the end of comments...

if (c=='<'|c=='>'|c=='='|c=='/')
//luckily they're all ops whether one char or two
{
if (rat.peek() == '=')
 { //return c + '=' as op
  cout << c << rat.get() << "   Operator\n"; }
else//if next char is valid
 { //return c as op
   cout << c << rat.get() << "   Operator\n"; }
}//if
}


//two char separators/operators check
void FSMtwochsep(){
switch (c){
 case '%': if (rat.peek() == '%') {
  cout << c << rat.get() << "   Separator\n";}
  break;
 case '[': if (rat.peek() == '*') {
  cout << c << rat.get() << "   Separator COM\n";}
  break;
 case '!': if (rat.peek() == '=') {
  cout << c << rat.get() << "    Operator\n";}
}//sw
}





for (char chep : disambig)
 if (c == chep) {
  FSMdisambig();
  }

for (char chep : twoc_seps_ch1)
 if (c == chep) {
  FSMtwochsep();
  }
for (char chep : twoc_ops_ch1)
 if (c == chep) {
  FSMtwochsep();
  }


for (char chep : onec_seps)
 if (c == chep) {
  //it's a one char separator and that's all, cool
  }

for (char chep : onec_ops)
 if (c == chep) {
  //it's a one char operator and that's all
  }

